-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package larceny
@version 0.1.0.0

module Web.Larceny.Html
html5Nodes :: HashSet Text


-- | A long description with example use with Scotty.
--   
--   It'll be something like:
--   
--   Write some templates.
--   
--   Add a <a>Library</a> to your Scotty state with <a>loadTemplates</a>.
--   
--   Write some <a>Substitutions</a>.
--   
--   Write some Larceny/Scotty glue.
--   
--   Use <a>render</a> and <a>renderWith</a> in your Scotty handlers.
--   
--   Admire your lovely app!!
module Web.Larceny

-- | A "blank" in the template that can be filled in with some value by
--   Haskell code. Blanks can be tags or they can be all or parts of
--   attribute values in tags.
--   
--   Example blanks:
--   
--   <pre>
--   &lt;skater&gt;                           &lt;- "skater"
--   &lt;p class=${name}&gt;                  &lt;- "name"
--   &lt;skater name="${name}"&gt;            &lt;- both "skater" and "name"
--   &lt;a href="teams/${team}/{$number}"&gt; &lt;- both "team" and number"
--   </pre>
newtype Blank
Blank :: Text -> Blank

-- | A Fill is how to fill in a Blank.
--   
--   In most cases, you can use helper functions like <a>textFill</a> or
--   <a>fillChildrenWith</a> to create your fills. You can also write Fills
--   from scratch.
--   
--   <pre>
--   Fill $ attrs _tpl _lib -&gt;
--            return $ T.pack $ show $ M.keys attrs)
--   </pre>
--   
--   With that Fill, a Blank like this:
--   
--   <pre>
--   &lt;displayAttrs attribute="hello!" another="goodbye!"/&gt;
--   </pre>
--   
--   would be rendered as:
--   
--   <pre>
--   ["attribute", "another"]
--   </pre>
--   
--   Fills (and Substitutions and Templates) have the type `StateT s IO
--   Text` in case you need templates to depend on IO actions (like looking
--   something up in a database) or store state (perhaps keeping track of
--   what's already been rendered).
newtype Fill s
Fill :: (Attributes -> (Path, Template s) -> Library s -> StateT s IO Text) -> Fill s
[unFill] :: Fill s -> Attributes -> (Path, Template s) -> Library s -> StateT s IO Text

-- | The Blank's attributes, a map from the attribute name to it's value.
type Attributes = Map Text Text

-- | A map from Blanks to how to fill in the Blank.
type Substitutions s = Map Blank (Fill s)

-- | When you run a Template with the path, some substitutions, and the
--   template library, you'll get back some stateful text.
--   
--   Use <a>loadTemplates</a> to load the templates from some directory
--   into a template library. Use the <a>render</a> functions to render
--   templates by path.
newtype Template s
Template :: (Path -> Substitutions s -> Library s -> StateT s IO Text) -> Template s
[runTemplate] :: Template s -> Path -> Substitutions s -> Library s -> StateT s IO Text

-- | The path to a template.
type Path = [Text]

-- | A collection of templates.
type Library s = Map Path (Template s)

-- | If no substitutions are given, Larceny only understands valid HTML 5
--   tags. It won't attempt to "fill in" tags that are already valid HTML
--   5. Use Overrides to use non-HTML 5 tags without providing your own
--   substitutions, or to provide fills for standard HTML tags.
--   
--   <pre>
--   -- Use the deprecated "marquee" and "blink" tags and write your
--   -- own fill for the "a" tag.
--   Overrides ["marquee", "blink"] ["a"]
--   </pre>
data Overrides
Overrides :: [Text] -> [Text] -> Overrides
[customPlainNodes] :: Overrides -> [Text]
[overrideNodes] :: Overrides -> [Text]

-- | Default uses no overrides.
defaultOverrides :: Overrides

-- | Render a template from the library by path.
--   
--   <pre>
--   render appTemplates appState ["path", "to", "template"]
--   </pre>
render :: Library s -> s -> Path -> IO (Maybe Text)

-- | Render a template from the library by path, with some additional
--   substitutions.
--   
--   <pre>
--   renderWith appTemplates extraSubs appState ["path", "to", "template"]
--   </pre>
renderWith :: Library s -> Substitutions s -> s -> Path -> IO (Maybe Text)

-- | Render a template found relative to current template's path.
--   
--   This will attempt to find the target template starting at the same
--   level as the given path, then will traverse up the directory tree
--   until it finds a template with the target path.
--   
--   For example: Given these templates: ["current"], ["current",
--   "dashboard"], ["current", "private", "dashboard"], ["private",
--   "dashboard"], <a>renderRelative</a> called with a given path of
--   ["current"] and target path of ["private", "dashboard"] will find
--   ["current", "private", "dashboard"]. If there <i>wasn't</i> a
--   ["current", "private", "dashboard"], it would render ["private",
--   "dashboard"].
renderRelative :: Library s -> Substitutions s -> s -> Path -> Path -> IO (Maybe Text)

-- | Load all the templates in some directory into a Library.
loadTemplates :: FilePath -> Overrides -> IO (Library s)

-- | Turn tuples of text and fills to Substitutions.
--   
--   <pre>
--   subs [("blank", textFill "the fill")
--        ,("another-blank", textFill "another fill")]
--   </pre>
subs :: [(Text, Fill s)] -> Substitutions s

-- | A plain text fill.
--   
--   <pre>
--   textFill "This text will be displayed in place of the blank"
--   </pre>
textFill :: Text -> Fill s

-- | Use state or IO, then fill in some text.
--   
--   <pre>
--   -- getTextFromDatabase :: StateT () IO Text
--   textFill' getTextFromDatabase
--   </pre>
textFill' :: StateT s IO Text -> Fill s

-- | Create substitutions for each element in a list and fill the child
--   nodes with those substitutions.
--   
--   <pre>
--   &lt;members&gt;&lt;name /&gt;&lt;/members&gt;
--   ("members", mapSubs (name -&gt; subs [("name", textFill name)])
--                       ["Bonnie Thunders", "Donna Matrix", "Beyonslay"]
--   </pre>
--   
--   <pre>
--   Bonnie Thunders Donna Matrix Beyonslay
--   </pre>
mapSubs :: (a -> Substitutions s) -> [a] -> Fill s

-- | Create substitutions for each element in a list (using IO/state if
--   needed) and fill the child nodes with those substitutions.
mapSubs' :: (a -> StateT s IO (Substitutions s)) -> [a] -> Fill s

-- | Fill in the child nodes of the blank with substitutions already
--   available.
--   
--   <pre>
--   &lt;no-op&gt;&lt;p&gt;Same&lt;/p&gt;&lt;/no-op&gt;
--   ("no-op", fillChildren)
--   </pre>
--   
--   <pre>
--   &lt;p&gt;Same&lt;/p&gt;
--   </pre>
fillChildren :: Fill s

-- | Fill in the child nodes of the blank with new substitutions.
--   
--   <pre>
--   &lt;member&gt;&lt;name /&gt;&lt;/member&gt;
--   ("skater", fillChildrenWith (subs $ [("name", textFill "Bonnie Thunders")]))
--   </pre>
--   
--   <pre>
--   Beyonslay
--   </pre>
fillChildrenWith :: Substitutions s -> Fill s

-- | Use substitutions with State and IO.
--   
--   <pre>
--   &lt;changeTheWorld&gt;&lt;results /&gt;&lt;/changeTheWorld&gt;
--   -- doABunchOfStuffAndGetSubstitutions :: StateT () IO (Substitutions ())
--   ("changeTheWorld", fillChildrenWith' doStuffAndGetSubstitutions)
--   </pre>
--   
--   <pre>
--   This template did IO!
--   </pre>
fillChildrenWith' :: StateT s IO (Substitutions s) -> Fill s

-- | Fill with substitutions if those substitutions are provided.
--   
--   <pre>
--   &lt;ifDisplayUser&gt;&lt;userName /&gt;&lt;/ifDisplayUser&gt;
--   ("ifDisplayUser", maybeFillChildrenWith
--                       (Just $ subs' ("userName", textFill "Bonnie Thunders")))
--   </pre>
--   
--   <pre>
--   Bonnie Thunders
--   </pre>
maybeFillChildrenWith :: Maybe (Substitutions s) -> Fill s

-- | Use state and IO and maybe fill in with some substitutions.
--   
--   <pre>
--   &lt;ifLoggedIn&gt;Logged in as &lt;userName /&gt;&lt;/ifLoggedIn&gt;
--   ("ifLoggedIn", maybeFillChildrenWith' $ do
--                    mUser &lt;- getLoggedInUser -- returns (Just "Bonnie Thunders")
--                    case mUser of
--                      Just user -&gt; Just $ subs' ("userName", textFill user)
--                      Nothing   -&gt; Nothing)
--   </pre>
--   
--   <pre>
--   Bonnie Thunders
--   </pre>
maybeFillChildrenWith' :: StateT s IO (Maybe (Substitutions s)) -> Fill s

-- | Use attributes from the the blank as arguments to the fill.
--   
--   <pre>
--   &lt;desc length="10" /&gt;
--   ("desc", useAttrs (a"length") descriptionFill)
--   descriptionFill len = textFill $ T.take len
--                                    "A really long description"
--                                    &lt;&gt; "..."))
--   </pre>
--   
--   <pre>
--   A really l...
--   </pre>
--   
--   <a>useAttrs</a> takes two arguments. The first is a way to get values
--   of attributes that you can use in Fills. You can use <a>a</a> and
--   <a>%</a> to create these. The second argument is a function that uses
--   the values of those attributes to create a Fill.
useAttrs :: (Attributes -> k -> Fill s) -> k -> Fill s

-- | A typeclass for things that can be parsed from attributes.
class FromAttribute a
fromAttribute :: FromAttribute a => Maybe Text -> Either AttrError a

-- | If an attribute is required but missing, or unparsable, one of these
--   errors is thrown.
data AttrError
AttrMissing :: AttrError
AttrUnparsable :: Text -> AttrError
AttrOtherError :: Text -> AttrError

-- | Prepend <a>a</a> to the name of an attribute to pass the value of that
--   attribute to the fill.
--   
--   The type of the attribute is whatever type the fill expects. If
--   <a>a</a> can't parse the value, then there will be an error when the
--   template is rendered.
a :: FromAttribute a => Text -> Attributes -> (a -> b) -> b

-- | Use with <a>a</a> to use multiple attributes in the fill.
--   
--   <pre>
--   &lt;desc length="10" /&gt;
--   ("desc", useAttrs (a"length" % a"ending") descriptionFill)
--   descriptionFill len maybeEnding =
--     let ending = fromMaybe "..." maybeEnding in
--     textFill $ T.take n
--                "A really long description"
--                &lt;&gt; ending))
--   </pre>
--   
--   <pre>
--   A really l...
--   </pre>
(%) :: (Attributes -> a -> b) -> (Attributes -> b -> c) -> Attributes -> a -> c

-- | Turn lazy text into templates.
parse :: Text -> Template s

-- | Use overrides when parsing a template.
parseWithOverrides :: Overrides -> Text -> Template s
instance GHC.Show.Show Web.Larceny.AttrError
instance GHC.Classes.Eq Web.Larceny.AttrError
instance Data.Hashable.Class.Hashable Web.Larceny.Blank
instance GHC.Classes.Ord Web.Larceny.Blank
instance GHC.Show.Show Web.Larceny.Blank
instance GHC.Classes.Eq Web.Larceny.Blank
instance Web.Larceny.FromAttribute Data.Text.Internal.Text
instance Web.Larceny.FromAttribute GHC.Types.Int
instance Web.Larceny.FromAttribute a => Web.Larceny.FromAttribute (GHC.Base.Maybe a)
